\documentclass{scrartcl}

\usepackage{longtable}
\usepackage{minted}

\title{Mars Rover Mission DSL}
\author{Erin van der Veen - s4431200\\
	Brigel Pineti - s1005549}

\begin{document}
\maketitle

\section{Mars Rover}
\subsection{Requirements}
Table~\ref{tab:requirements} shows the individual requirements, including their priority and a short description.
The ``scope'' of a requirement denotes what part of the rover the requirement relates to.
Note that ``DSL'' doesn't explicitly mean that a requirement must have a single command in the DSL.
Rather, it means that this behavior must be attainable through the constructs that are provided by the DSL.
\begin{longtable}{|l|p{1.7cm}|p{1cm}|p{4cm}|p{4cm}|}
	\hline
	Code & Name & Scope & Description & Ideas on Implementation \\\hline
	MH1 & Backwards of Table & DSL & At no instance should the Robot Drive backwards of the table & The Ultrasonic Sensor in the back of the robot seems like the best candidate to determine if the Rover is about to drive of the table. \\\hline
	MH2 & Stay within White Border & DSL & At no Point should the robot move outside the white border. & This requirement has slight overlap with MH1. The color sensors can be used to measure the white border, after which a turn can be made based on which of the sensors read the white color.\\\hline
	MH3 & Avoid Lakes & DSL & The Rover should never drive into one of the ``lakes''. & For forward movement, this can be sensed using the color sensors (every lake has a distinct color), for backwards movement the behavior from MH1 can be used.\\\hline
	MH4 & Avoid Rocks & DSL & The Rover should not run into rocks, unless with the explicit purpose of pushing the rock out of the field & \\\hline
	MH5 & Subsump-tion Architecture & C++ & Currently, the behavior framework waits until a behavior is completed before it assesses which behavior should be ``executed'' next. Ideally, a behavior should be terminated as soon as another behavior of higher priority indicates that is much be executed. & Two threads will be created, one that will deal with the execution of the behaviors, one that will constantly assess which behavior must run. \\\hline
	SH1 & Detect lakes & DSL & The rover should be able to at least find all lakes. & This does not necessarily mean that is must ``measure'' every lake, rather, that it should find all colors. \\\hline
	SH2 & Measure lakes & DSL & The rover should be able to measure each lake once it has found one, it should try to avoid measuring the same lake twice. & A variable system must be implemented to store the knowledge base of the Rover.\\\hline
	SH3 & Measure Rocks & DSL & Once a rock is found, the robot should be able to ``measure'' this rock. & \\\hline
	CH1 & Clean up Rocks & DSL & Once a rock is ``measured'', the rover can push this rock out of the field & \\\hline
	CH2 & Play Sound & DSL & The Rover could be able to play a sound whenever necessary & This must be implemented in both the DSL and C++ \\\hline
	WH1 & Path-finding & DSL / C++ & The Robot will not be able to look ahead, or have a internal representation of the field & \\\hline
	\caption{Requirements of the Mars Rover DSL and Implementation, the code of a given requirement also indicates its priority. With MH = Must Have, SH = Should Have, CH = Could Have, WH = Wont Have.
		The Subsumption Architecture could be considered as a ``How'' rather than ``What'', but this would be incorrect.
		It simply denotes the expected behavior that must arise from the DSL.
		This is part of the specification of the DSL, and thus part of the ``What''.
		We do provide an idea on how to implement this requirement, but we do that for multiple requirements, not only this one.}
\label{tab:requirements}
\end{longtable}

\subsection{Configuration}
Table~\ref{tab:config_p} shows the proposed configuration in the way is was given in the slides.
The decision was based on the core concept that Brick 1 is the master, and Brick 2 is the slave.
This implies that all systems (sensors and motors) that require fast interaction are connected to Brick 1, all other systems are connected to Brick 2.
It would be ideal if at least one color sensor (the center one) could also be connected to Brick 1, since it can be used to determine if the Robot is about to drive of the table.
We argue, however, that the separation of concerns (all similar sensors should be connected to one brick) is more important than connecting this sensor to Brick 1.
The separation of concerns makes the code that will be generated by the DSL potentially much more readable.
\begin{table}
	\centering
	\begin{tabular}{|l|p{5cm}|p{5cm}|}
		\hline
		& EV3 Brick 1 & EV3 Brick 2 \\\hline
		Actuators & Left Motor \newline Right Motor & Measurement Motor \\\hline
		Sensors & Ultrasonic \{Front, Rear\} \newline Touch \{Left, Right\} & Color \{Left, Mid, Right\} \newline Gyro \\\hline
	\end{tabular}
	\caption{The Configuration of the two bricks as proposed}
	\label{tab:config_p}
\end{table}

Table~\ref{tab:config_c} shows the configuration that was chosen for all Mars Rovers.
There is a substantial difference between our proposed configuration and the one that was chosen.
\begin{enumerate}
	\item The color sensors are split, the idea behind this is that we must act quickly when the Left or Right color sensors read a color.
		In our proposal, we argue that this is actually a good idea, but also explain why we chose not to do this.
	\item The Front Ultrasonic sensor is moved onto Brick 2.
		Again, we argued that keeping similar concerns on the same brick was more important that the initial idea.
	\item Touch and Gyro sensors are on the opposite Brick.
		The idea behind this is that you must interact quickly when the gyro reaches a certain value.
		This doesn't make any sense at all, if this is the case, why did we chose to place the front ultrasonic sensor on Brick 1?
		In class, it was argued that with the ultrasonic sensor ``you can correct for the extra time that is necessary to respond, this is not possible for the Gyro.''
		How could this not be possible for the Gyro?
		If you set the speed of the motors to a certain value, you will always turn at a specific rate.
\end{enumerate}
\begin{table}
	\centering
	\begin{tabular}{|l|p{5cm}|p{5cm}|}
		\hline
		& EV3 Brick 1 & EV3 Brick 2 \\\hline
		Actuators & Left Motor \newline Right Motor \newline Measurement Motor & \\\hline
		Sensors & Color \{Left, Right\} \newline Ultrasonic Back \newline Gyro & Color Mid \newline Ultrasonic Front \newline Touch \{Left, Right\} \\\hline
	\end{tabular}
	\caption{The Configuration of the two bricks as chosen}
	\label{tab:config_c}
\end{table}

\subsection{Planning}
Table~\ref{tab:plan} shows the development plan in its most pessimistic form.
Table~\ref{tab:dev} shows the development as it was actually done by us.
\begin{table}
	\centering
	\begin{tabular}{|l|l|l|}
		\hline
		Week nr & Deadline & Plan \\\hline
		Week 0 & 28 Nov & Requirements, Configuration, Plan \\\hline
		Week 1 & 5 Dec & MH5, MH1 \\\hline
		Week 2 & 12 Dec & MH2 MH3, MH4 \\\hline
		Week 3 & 19 Dec & SH1, SH2, SH3 \\\hline
		Week 4 & 26 Dec & CH1, CH2, and Extra \\\hline
	\end{tabular}
	\caption{The Development Schedule}
	\label{tab:plan}
\end{table}
\begin{table}
	\centering
	\begin{tabular}{|l|l|l|}
		\hline
		Week nr & Deadline & Plan \\\hline
		Week 0 & 28 Nov & Requirements, Configuration, Plan \\\hline
		Week 1 & 5 Dec & MH5, MH1, MH2\\\hline
		Week 2 & 12 Dec & Bluetooth \\\hline
		Week 3 & 19 Dec & MH3, MH4, SH1, SH2, SH3, CH1 \\\hline
		Week 4 & 26 Dec & Refinement \\\hline
	\end{tabular}
	\caption{The Development as it was actually performed}
	\label{tab:dev}
\end{table}

In the Evaluation we will discus why the original plan didn't work out for us and how we managed to complete so many requirements in week 3.

\subsection{Domain Specific Language}
\subsubsection{Concept/Grammar}
The Mars Rover was not designed with a specific goal in mind part from doing research on mars.
We wanted this to reflect in our DSL, and therefore decided to create a very low level imperative task based DSL.
\begin{minted}{antlr}
Mission:
	'Mission' name = ID
	('Variables:' variables += Variable+)?
	'Behaviors:' behaviours += Behaviour+
;
\end{minted}

\paragraph{Variables}
Making such a low level DSL implies that the user must be able to specify how far completed the mission is.
This, naturally, led to the implementation of a boolean variable system.
Ideally, one would also like to allow the definition of other types of variables.
This is not implemented in the current version of the DSL due to time constraints.
\begin{minted}{antlr}
Variable:
	name = ID
	("=" value = TruthValue)?
;
\end{minted}

\paragraph{Behavior}
Every Mission (program specification) consists of a set of behaviors.
The order in which these behaviors are defined in the Mission determines the priority.
The first specified behavior has the highest priority.
Behaviors consist of a set of Conditions and a set of Actions.
The set of Conditions determine when a behavior must be executed, if this is the case the actions of the corresponding behavior are executed.
The Control argument of a behavior will be explained later.
For now, you can assume that only behaviors with a higher priority will subsume the current behavior when their condition is true.
\begin{minted}{antlr}
Behaviour:
	name = ID ':' control = Control
	('Conditions:' conditions += (Condition | Variable)*)?
	'Actions:' actions += Action+
;
\end{minted}

\paragraph{Condition}
A condition as mentioned above can be either a variable or a condition.
Right now, the syntax of the variable as a constraint is the same as assignment.
Ideally, we would extend this to use normal equality operators.
If we want to allow other types than booleans, this is a must have as well.
The syntax of the other type of conditions is designed to consider the current sensor input.
The \mintinline{antlr}{Value} type holds all possible output (Colors, Distance, Pressed/Unpressed), the \mintinline{antlr}{Operator} type is an enumeration of all common equality operators.
Note, that these operators are not supported for \mintinline{antlr}{Variables}.
\begin{minted}{antlr}
Condition:
	sensor = Sensor
	operator = Operator
	value = Value
;
\end{minted}

\paragraph{Action}
The Actions are mappings to the actuators of the Robot with a certain level of abstraction.
\begin{minted}{antlr}
Action:
	Move | Turn | Variable | Complete | Arm | Stop
;
\end{minted}
Every action has a set expected behavior for the robot:
\begin{description}
	\item[\mintinline{antlr}{Move :: Direction Distance}] The Robot moves \texttt{Direction} for \texttt{Distance} centimeters
	\item[\mintinline{antlr}{Turn :: Direction Degrees}] The Robot turns \texttt{Direction} for \texttt{Degrees} degrees
	\item[\mintinline{antlr}{Variable :: Name Value}] Set the variable \texttt{Name} to \texttt{Value}
	\item[\mintinline{antlr}{Complete :: ReturnCode}] The program terminates with code \texttt{ReturnCode}
	\item[\mintinline{antlr}{Arm :: Direction}] The measurement arm moves \texttt{Direction}
	\item[\mintinline{antlr}{Stop}] The Robot stops moving
\end{description}

\paragraph{Control}
Earlier I hinted at the control parameter that is specified for each possible behavior.
I also mentioned that, until now, it was assumed that only a task of a higher priority subsumes behaviors of a lower priority.
With this definition in mind, let us consider the following situation with two behaviors:
\begin{minted}{python}
AvoidBorder : Block
	Conditions:
		colorSensor center == Black
	Actions:
		Move backward 10 cm
		Turn left 50 degrees

WatchYourBack : Pass
	Conditions:
		ultrasonicSensor back > 3 cm
	Actions:
		Move forward 100 cm

Walk : Pass
	Actions:
		Move forward 100 cm
\end{minted}

For the \texttt{AvoidBorder} behavior, we want the Robot to go back, and then turn left for 50 degrees.
Only after we have done this do we want to continue walking.
Note, that even before we turn left, the condition of the \texttt{AvoidBorder} is no longer true.
This means that \texttt{Walk} would then become the behavior with the highest priority for which the condition is true.
However, we only want to walk after we have completed \texttt{AvoidBorder}.

Let's now consider the situation where the \texttt{WachtYourBack} condition is met, and the robot suddenly moves forward in order to avoid falling of the edge.
Unlike the in paragraph above, we want to continue walking as soon as the border has been avoided.
This means, that as soon as the conditions of the current behavior is no longer true, we want the program to also consider behaviors with a lower priority (even if the current actions have no been completed).

This is where the \texttt{Control} enumeration comes into play.
\texttt{BLOCK} means that the current behavior blocks the execution of all behaviors with a lower priority for as long as it is executing its actions.
\texttt{PASS} means that the current behavior only blocks the execution of behaviors with a lower priority for as long as his own conditions are true. There is another control keyword (\texttt{SKIP}), which has some very subtle properties (and allows fast setting of variables without executing actions).
The DSL does allow specifying this keyword, but it should not be used.

\subsubsection{Implementation}
\paragraph{RobotAction}
The C++ code that is generated from the DSL, has a pure virtual class called \texttt{RobotAction}. That is defined as follows:
\begin{minted}{cpp}
class RobotAction {
	public:
		enum Control { SKIP, BLOCK, PASS };
		virtual Control takeControl() = 0;
		virtual void perform() = 0;
		virtual void printName() = 0;
};
\end{minted}
As we can see, the \texttt{Control} enumeration holds the \texttt{Control} argument of the behaviors.
The \mintinline{cpp}{Control takeControl()} function is used to check the conditions specified in the DSL.
Likewise, the \mintinline{cpp}{void perform()} function holds all the actions that are executed by this Behavior/RobotAction.

\paragraph{Artbitrator}
The class that deals with the subsumption and all related tasks is the \texttt{Arbitrator}.
It will continuously check if there is a \texttt{RobotAction} that has priority.
If this is the case, the current action is terminated and the other action is started.
If the Robot manages to finish a task without getting subsumed, it itself invokes a run of the Arbitrator.
This is done the make the time between actions as small as possible.

\paragraph{Bluetooth}
There are several implementation problems that arose when we tried to implement the link between the slave and master robot.
Ideally we want a Mars Rover to be as deterministic as possible.
Or, more nuanced, we want to be able to predict what the action of the robot will be at any point in time.
This means that we, ourselves, want to be able to invoke the Bluetooth task that receives the data from the slave.
Similar to how the JVM allows you to disable the Garbage Collector, so you must invoke it yourself.
In order to do this, there are two options.
\begin{enumerate}
	\item Give the Bluetooth task the lowest priority, and sleeping all other tasks to invoke it.
	\item Make reading non blocking.
\end{enumerate}

The first turned out to have the unfortunate side effect that you would never be sure how much of the bluetooth buffer you have read.
A hack to solve this would be to ensure that you always read more than you write.
However, this is undesirable, since we could well use the time to execute actions on the robot.

The second option should be simple.
There are several options that could have been used to make reading non-blocking:
\begin{description}
	\item[\mintinline{cpp}{select()}] Implemented incorrectly, never reaches timeout.
	\item[\mintinline{cpp}{poll()}] Implemented incorrectly, should be non-blocking but is.
	\item[\mintinline{cpp}{read()}] Implemented incorrectly, should be non-blocking but is.
	\item[\mintinline{cpp}{fgets()}] Implemented incorrectly, should be non-blocking but is.
	\item[\mintinline{cpp}{seek()}] Available, but unsupported on Bluetooth filedescriptor.
	\item[\mintinline{cpp}{rewind()}] Available, but unsupported on Bluetooth filedescriptor.
\end{description}
Unfortunately, as you can read above, nearly all options we had for making the reading non-blocking were not properly supported on the OS.

In the end, this meant that we had to settle for the approach that we also used last weeks.
We set the Bluetooth task to have the highest priority, and accept the fact that the behavior of the Mars Rover is no longer deterministic.

\section{Evaluation}

\end{document}
