\documentclass{scrartcl}

\usepackage{longtable}
\usepackage{minted}
\setmintedinline{breaklines}

\title{Mars Rover Mission DSL}
\author{Erin van der Veen - s4431200\\
	Brigel Pineti - s1005549}

\begin{document}
\maketitle

\section{Mars Rover}
\subsection{Requirements}
Table~\ref{tab:requirements} shows the individual requirements, including their priority and a short description.
The ``scope'' of a requirement denotes what part of the rover the requirement relates to.
Note that ``DSL'' doesn't explicitly mean that a requirement must have a single command in the DSL.
Rather, it means that this behavior must be attainable through the constructs that are provided by the DSL.
\begin{longtable}{|l|p{1.7cm}|p{1cm}|p{4cm}|p{4cm}|}
	\hline
	Code & Name & Scope & Description & Ideas on Implementation \\\hline
	MH1 & Backwards of Table & DSL & At no instance should the Robot Drive backwards of the table & The Ultrasonic Sensor in the back of the robot seems like the best candidate to determine if the Rover is about to drive of the table. \\\hline
	MH2 & Stay within White Border & DSL & At no Point should the robot move outside the white border. & This requirement has slight overlap with MH1. The color sensors can be used to measure the white border, after which a turn can be made based on which of the sensors read the white color.\\\hline
	MH3 & Avoid Lakes & DSL & The Rover should never drive into one of the ``lakes''. & For forward movement, this can be sensed using the color sensors (every lake has a distinct color), for backwards movement the behavior from MH1 can be used.\\\hline
	MH4 & Avoid Rocks & DSL & The Rover should not run into rocks, unless with the explicit purpose of pushing the rock out of the field & \\\hline
	MH5 & Subsump-tion Architecture & C++ & Currently, the behavior framework waits until a behavior is completed before it assesses which behavior should be ``executed'' next. Ideally, a behavior should be terminated as soon as another behavior of higher priority indicates that is much be executed. & Two threads will be created, one that will deal with the execution of the behaviors, one that will constantly assess which behavior must run. \\\hline
	SH1 & Detect lakes & DSL & The rover should be able to at least find all lakes. & This does not necessarily mean that is must ``measure'' every lake, rather, that it should find all colors. \\\hline
	SH2 & Measure lakes & DSL & The rover should be able to measure each lake once it has found one, it should try to avoid measuring the same lake twice. & A variable system must be implemented to store the knowledge base of the Rover.\\\hline
	SH3 & Measure Rocks & DSL & Once a rock is found, the robot should be able to ``measure'' this rock. & \\\hline
	CH1 & Clean up Rocks & DSL & Once a rock is ``measured'', the rover can push this rock out of the field & \\\hline
	CH2 & Play Sound & DSL & The Rover could be able to play a sound whenever necessary & This must be implemented in both the DSL and C++ \\\hline
	WH1 & Path-finding & DSL / C++ & The Robot will not be able to look ahead, or have a internal representation of the field & \\\hline
	\caption{Requirements of the Mars Rover DSL and Implementation, the code of a given requirement also indicates its priority. With MH = Must Have, SH = Should Have, CH = Could Have, WH = Wont Have.
		The Subsumption Architecture could be considered as a ``How'' rather than ``What'', but this would be incorrect.
		It simply denotes the expected behavior that must arise from the DSL.
		This is part of the specification of the DSL, and thus part of the ``What''.
		We do provide an idea on how to implement this requirement, but we do that for multiple requirements, not only this one.}
\label{tab:requirements}
\end{longtable}

\subsection{Configuration}
Table~\ref{tab:config_p} shows the proposed configuration in the way is was given in the slides.
The decision was based on the core concept that Brick 1 is the master, and Brick 2 is the slave.
This implies that all systems (sensors and motors) that require fast interaction are connected to Brick 1, all other systems are connected to Brick 2.
It would be ideal if at least one color sensor (the center one) could also be connected to Brick 1, since it can be used to determine if the Robot is about to drive of the table.
We argue, however, that the separation of concerns (all similar sensors should be connected to one brick) is more important than connecting this sensor to Brick 1.
The separation of concerns makes the code that will be generated by the DSL potentially much more readable.
\begin{table}
	\centering
	\begin{tabular}{|l|p{5cm}|p{5cm}|}
		\hline
		& EV3 Brick 1 & EV3 Brick 2 \\\hline
		Actuators & Left Motor \newline Right Motor & Measurement Motor \\\hline
		Sensors & Ultrasonic \{Front, Rear\} \newline Touch \{Left, Right\} & Color \{Left, Mid, Right\} \newline Gyro \\\hline
	\end{tabular}
	\caption{The Configuration of the two bricks as proposed}
	\label{tab:config_p}
\end{table}

Table~\ref{tab:config_c} shows the configuration that was chosen for all Mars Rovers.
There is a substantial difference between our proposed configuration and the one that was chosen.
\begin{enumerate}
	\item The color sensors are split, the idea behind this is that we must act quickly when the Left or Right color sensors read a color.
		In our proposal, we argue that this is actually a good idea, but also explain why we chose not to do this.
	\item The Front Ultrasonic sensor is moved onto Brick 2.
		Again, we argued that keeping similar concerns on the same brick was more important that the initial idea.
	\item Touch and Gyro sensors are on the opposite Brick.
		The idea behind this is that you must interact quickly when the gyro reaches a certain value.
		This doesn't make any sense at all, if this is the case, why did we chose to place the front ultrasonic sensor on Brick 1?
		In class, it was argued that with the ultrasonic sensor ``you can correct for the extra time that is necessary to respond, this is not possible for the Gyro.''
		How could this not be possible for the Gyro?
		If you set the speed of the motors to a certain value, you will always turn at a specific rate.
\end{enumerate}
\begin{table}
	\centering
	\begin{tabular}{|l|p{5cm}|p{5cm}|}
		\hline
		& EV3 Brick 1 & EV3 Brick 2 \\\hline
		Actuators & Left Motor \newline Right Motor \newline Measurement Motor & \\\hline
		Sensors & Color \{Left, Right\} \newline Ultrasonic Back \newline Gyro & Color Mid \newline Ultrasonic Front \newline Touch \{Left, Right\} \\\hline
	\end{tabular}
	\caption{The Configuration of the two bricks as chosen}
	\label{tab:config_c}
\end{table}

\subsection{Planning}
Table~\ref{tab:plan} shows the development plan in its most pessimistic form.
Table~\ref{tab:dev} shows the development as it was actually done by us.
\begin{table}
	\centering
	\begin{tabular}{|l|l|l|}
		\hline
		Week nr & Deadline & Plan \\\hline
		Week 0 & 28 Nov & Requirements, Configuration, Plan \\\hline
		Week 1 & 5 Dec & MH5, MH1 \\\hline
		Week 2 & 12 Dec & MH2 MH3, MH4 \\\hline
		Week 3 & 19 Dec & SH1, SH2, SH3 \\\hline
		Week 4 & 26 Dec & CH1, CH2, and Extra \\\hline
	\end{tabular}
	\caption{The Development Schedule}
	\label{tab:plan}
\end{table}
\begin{table}
	\centering
	\begin{tabular}{|l|l|l|}
		\hline
		Week nr & Deadline & Plan \\\hline
		Week 0 & 28 Nov & Requirements, Configuration, Plan \\\hline
		Week 1 & 5 Dec & MH5, MH1, MH2\\\hline
		Week 2 & 12 Dec & Bluetooth \\\hline
		Week 3 & 19 Dec & MH3, MH4, SH1, SH2, SH3, CH1 \\\hline
		Week 4 & 26 Dec & Refinement \\\hline
	\end{tabular}
	\caption{The Development as it was actually performed}
	\label{tab:dev}
\end{table}

In the Evaluation we will discus why the original plan didn't work out for us and how we managed to complete so many requirements in week 3.

\subsection{Domain Specific Language}
\subsubsection{Concept/Grammar}
The Mars Rover was not designed with a specific goal in mind part from doing research on mars.
We wanted this to reflect in our DSL, and therefore decided to create a very low level imperative task based DSL.
\begin{minted}{antlr}
Mission:
	'Mission' name = ID
	('Variables:' variables += Variable+)?
	'Behaviors:' behaviours += Behaviour+
;
\end{minted}

\paragraph{Variables}
Making such a low level DSL implies that the user must be able to specify how far completed the mission is.
This, naturally, led to the implementation of a boolean variable system.
Ideally, one would also like to allow the definition of other types of variables.
This is not implemented in the current version of the DSL due to time constraints.
\begin{minted}{antlr}
Variable:
	name = ID
	("=" value = TruthValue)?
;
\end{minted}

\paragraph{Behavior}
Every Mission (program specification) consists of a set of behaviors.
The order in which these behaviors are defined in the Mission determines the priority.
The first specified behavior has the highest priority.
Behaviors consist of a set of Conditions and a set of Actions.
The set of Conditions determine when a behavior must be executed, if this is the case the actions of the corresponding behavior are executed.
The Control argument of a behavior will be explained later.
For now, you can assume that only behaviors with a higher priority will subsume the current behavior when their condition is true.
\begin{minted}{antlr}
Behaviour:
	name = ID ':' control = Control
	('Conditions:' conditions += (Condition | Variable)*)?
	'Actions:' actions += Action+
;
\end{minted}

\paragraph{Condition}
A condition as mentioned above can be either a variable or a condition.
Right now, the syntax of the variable as a constraint is the same as assignment.
Ideally, we would extend this to use normal equality operators.
If we want to allow other types than booleans, this is a must have as well.
The syntax of the other type of conditions is designed to consider the current sensor input.
The \mintinline{antlr}{Value} type holds all possible output (Colors, Distance, Pressed/Unpressed), the \mintinline{antlr}{Operator} type is an enumeration of all common equality operators.
Note, that these operators are not supported for \mintinline{antlr}{Variables}.
\begin{minted}{antlr}
Condition:
	sensor = Sensor
	operator = Operator
	value = Value
;
\end{minted}
As we can see, it is possible to make comparisons that do not quite make sense.
Consider, for example, the following: \mintinline{Java}{ultrasonic left == Yellow}.
In order to prevent such constructions, we use validations rules that make use of the \mintinline{Java}{instanceof} keyword.
Without such constraints the code that is generated by the generator could, in certain cases, not be compilable by gcc.

\paragraph{Action}
The Actions are mappings to the actuators of the Robot with a certain level of abstraction.
\begin{minted}{antlr}
Action:
	Move | Turn | Variable | Complete | Arm | Stop
;
\end{minted}
Every action has a set expected behavior for the robot:
\begin{description}
	\item[\mintinline{antlr}{Move :: Direction Distance}] The Robot moves \texttt{Direction} for \texttt{Distance} centimeters
	\item[\mintinline{antlr}{Turn :: Direction Degrees}] The Robot turns \texttt{Direction} for \texttt{Degrees} degrees
	\item[\mintinline{antlr}{Variable :: Name Value}] Set the variable \texttt{Name} to \texttt{Value}
	\item[\mintinline{antlr}{Complete :: ReturnCode}] The program terminates with code \texttt{ReturnCode}
	\item[\mintinline{antlr}{Arm :: Direction}] The measurement arm moves \texttt{Direction}
	\item[\mintinline{antlr}{Stop}] The Robot stops moving
\end{description}

Unlike with the conditions, we do not need a special validator for this.
The actions are all contained within their own specific class.
As such, all rules are validated implicitly.

\paragraph{Control}
Earlier I hinted at the control parameter that is specified for each possible behavior.
I also mentioned that, until now, it was assumed that only a task of a higher priority subsumes behaviors of a lower priority.
With this definition in mind, let us consider the following situation with two behaviors:
\begin{minted}{python}
AvoidBorder : Block
	Conditions:
		colorSensor center == Black
	Actions:
		Move backward 10 cm
		Turn left 50 degrees

WatchYourBack : Pass
	Conditions:
		ultrasonicSensor back > 3 cm
	Actions:
		Move forward 100 cm

Walk : Pass
	Actions:
		Move forward 100 cm
\end{minted}

For the \texttt{AvoidBorder} behavior, we want the Robot to go back, and then turn left for 50 degrees.
Only after we have done this do we want to continue walking.
Note, that even before we turn left, the condition of the \texttt{AvoidBorder} is no longer true.
This means that \texttt{Walk} would then become the behavior with the highest priority for which the condition is true.
However, we only want to walk after we have completed \texttt{AvoidBorder}.

Let's now consider the situation where the \texttt{WachtYourBack} condition is met, and the robot suddenly moves forward in order to avoid falling of the edge.
Unlike the in paragraph above, we want to continue walking as soon as the border has been avoided.
This means, that as soon as the conditions of the current behavior is no longer true, we want the program to also consider behaviors with a lower priority (even if the current actions have no been completed).

This is where the \texttt{Control} enumeration comes into play.
\texttt{BLOCK} means that the current behavior blocks the execution of all behaviors with a lower priority for as long as it is executing its actions.
\texttt{PASS} means that the current behavior only blocks the execution of behaviors with a lower priority for as long as his own conditions are true. There is another control keyword (\texttt{SKIP}), which has some very subtle properties (and allows fast setting of variables without executing actions).
The DSL does allow specifying this keyword, but it should not be used.

\subsubsection{Implementation}
\paragraph{RobotAction}
The C++ code that is generated from the DSL, has a pure virtual class called \texttt{RobotAction}. That is defined as follows:
\begin{minted}{cpp}
class RobotAction {
	public:
		enum Control { SKIP, BLOCK, PASS };
		virtual Control takeControl() = 0;
		virtual void perform() = 0;
		virtual void printName() = 0;
};
\end{minted}
As we can see, the \texttt{Control} enumeration holds the \texttt{Control} argument of the behaviors.
The \mintinline{cpp}{Control takeControl()} function is used to check the conditions specified in the DSL.
Likewise, the \mintinline{cpp}{void perform()} function holds all the actions that are executed by this Behavior/RobotAction.

\paragraph{Artbitrator}
The class that deals with the subsumption and all related tasks is the \texttt{Arbitrator}.
It will continuously check if there is a \texttt{RobotAction} that has priority.
If this is the case, the current action is terminated and the other action is started.
If the Robot manages to finish a task without getting subsumed, it itself invokes a run of the Arbitrator.
This is done the make the time between actions as small as possible.

\paragraph{Bluetooth}
There are several implementation problems that arose when we tried to implement the link between the slave and master robot.
Ideally we want a Mars Rover to be as deterministic as possible.
Or, more nuanced, we want to be able to predict what the action of the robot will be at any point in time.
This means that we, ourselves, want to be able to invoke the Bluetooth task that receives the data from the slave.
Similar to how the JVM allows you to disable the Garbage Collector, so you must invoke it yourself.
In order to do this, there are two options.
\begin{enumerate}
	\item Give the Bluetooth task the lowest priority, and sleeping all other tasks to invoke it.
	\item Make reading non blocking.
\end{enumerate}

The first turned out to have the unfortunate side effect that you would never be sure how much of the bluetooth buffer you have read.
A hack to solve this would be to ensure that you always read more than you write.
However, this is undesirable, since we could well use the time to execute actions on the robot.

The second option should be simple.
There are several options that could have been used to make reading non-blocking:
\begin{description}
	\item[\mintinline{cpp}{select()}] Implemented incorrectly, never reaches timeout.
	\item[\mintinline{cpp}{poll()}] Implemented incorrectly, should be non-blocking but is.
	\item[\mintinline{cpp}{read()}] Implemented incorrectly, should be non-blocking but is.
	\item[\mintinline{cpp}{fgets()}] Implemented incorrectly, should be non-blocking but is.
	\item[\mintinline{cpp}{seek()}] Available, but unsupported on Bluetooth filedescriptor.
	\item[\mintinline{cpp}{rewind()}] Available, but unsupported on Bluetooth filedescriptor.
\end{description}
Unfortunately, as you can read above, nearly all options we had for making the reading non-blocking were not properly supported on the OS.

In the end, this meant that we had to settle for the approach that we also used last weeks.
We set the Bluetooth task to have the highest priority, and accept the fact that the behavior of the Mars Rover is no longer deterministic.

\section{Evaluation}
\subsection{DSL and Code Generation}
The entire codebase is based on a previous project by Erin that was made for the LeapMotion.
This project was always created with the intent to allow extensibility.
Unfortunately some changes were needed to allow use in the Mars Rover.
Most notably, explicit support for multi threading was added, and the behaviors of the SKIP, BLOCK and PASS were changed.

In reflection, using this framework allows us to create a very powerful DSL, but it does make it very verbose.
If we had the option to recreate the DSL, a state machine based approach would probably better suit the use case.
Not only would it allow smaller DSL code, but it would make reasoning much easier for the end user.

Code generation was very straightforward, since it is on a very low level.
The fact that it was created on such a low level means that, in practice, any desired mission can be programmed.
However, the DSL does not include configuration, so change in that aspect of the robot requires modification to the C++-generator.

Adding other features to the DSL is a very straightforward process.
Most of our time was spent on getting the framework to be as extensible as possible.
This, in turn, means that modifications to framework are hardly ever needed for the new feature to work.

\subsection{Development}
The development schedule was hard to keep up to because we were unable to determine how long the implementation of a feature would take.
This is largely due to the incomplete documentation that we had to work with.
I will talk more about that later.
All in all, we thought that we would need more time implementing the actual features of the DSL.
This is a good thing, because it allowed us to spend more time on the perfection of the framework.

Other than that, in general, we spend less time on the development that we expected.

Development in general was done through eclipse.
Neither of us had ever worked with eclipse, and it took quite some time to get used to the intricacy's of the IDE.
Dealing with the instability and performance of Java, was the biggest issue.

\subsection{Kernel, OS, SDK}
The Bluetooth added a unnecessary layer of complexity to the design of the Mars Rover.
In general, this would not be a problem if Bluetooth was actually properly supported by the OS that we were forced to use.
The fact that this was not the case, and that the documentation of all system calls is only available in Japanese, made the implementation of the Bluetooth connection very frustrating.

There are some other things about the OS/SDK that can make it fairly frustrating to work with.

Firstly, all system calls and other library functions were statically linked/compiled with the application.
There is absolutely no need to be the case.
The kernel could just support dynamic linking, and do this runtime.
This would not only prevent having bloated applications, but would also allow us to use whatever toolchain we prefer.
For example, with the way that the current sdk works, it is (very) hard to elegantly link user created libraries in the final binary.
If we could use our own toolchain, the only thing we had to ensure, is that it can dynamically link with the library provided by ev3rt.

Secondly, they use a lot of POSIX syscalls \mintinline{cpp}{read, select, fopen, write, poll, seek, open, etc} but for most of these the behavior is different to the one specified by the POSIX standard.
As mentioned above, this would not be a major problem if we were able to read the documentation.
But, as it stands, neither of us is able to read Japanese.

\subsection{Eclipse, Xtext, Xtend}
Eclipse is a very large IDE that is designed primarily for use with Java.
This implies that it comes with a lot of features that we did not use during this project.
While this is not generally a problem, the result is that eclipse is very bloated.

The fact that we were also obligated to use specific extensions meant, again, that we could not use our preferred toolchain.
We propose using parser generators like GNU Bison to prevent being obliged to use eclipse.

\subsection{DSL's in General}
DSL's have a very specific use case, and we do not know if the Mars rover is a good use case.
In general the Mars rover is likely to have very limited hardware available, in such a use case we want to be able to program as efficiently as possible.
Part of this means that we do not want big parts of the abstraction that DSL's provide us.
I would like to compare this to imperative versus functional programming.
Functional programs are much less likely to have a bug, but their performance is much worse than imperative programs.

Another point that we are not convinced of, is the readability of DSL's.
We assume that the goal of many DSL's is to allow domain experts to program without the help of programmers.
With the DSL's that we have seen during the course, and with the idea that DSL's need to be extensible, we do not see how domain experts would be able to write programs in such DSL's.
We do, however, recognize that DSL's are much easier to read for domain experts.
Here, we see great potential.
Programmers are able to write their code in the DSL, and domain experts would be able to verify if the implementation is actually correct.

\end{document}
